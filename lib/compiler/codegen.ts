import type {
  Program,
  Statement,
  Expression,
  FunctionDeclaration,
  LetDeclaration,
  ConstDeclaration,
} from "./types";

// Map LUXBIN types to Solidity types
const TYPE_MAP: Record<string, string> = {
  photon_int: "int256",
  photon_float: "int256", // No native float in Solidity
  photon_string: "string",
  photon_bool: "bool",
  photon_array: "int256[]",
  qubit: "uint256", // Placeholder
};

function solType(luxbinType: string | null, memoryQualifier = false): string {
  if (!luxbinType) return "int256";
  const mapped = TYPE_MAP[luxbinType] || "int256";
  if (memoryQualifier && (mapped === "string" || mapped.endsWith("[]"))) {
    return mapped + " memory";
  }
  return mapped;
}

export class SolidityCodegen {
  private warnings: string[] = [];
  private contractName: string;
  private stateVars: string[] = [];
  private stateArrayInits: string[] = [];
  private functions: string[] = [];
  private constructorLines: string[] = [];
  private usesLog = false;
  private usesLogInt = false;
  private usesLogBool = false;

  constructor(contractName = "LuxbinContract") {
    this.contractName = contractName;
  }

  generate(program: Program): { solidity: string; warnings: string[] } {
    // Classify top-level statements
    for (const stmt of program.body) {
      switch (stmt.type) {
        case "LetDeclaration":
          this.generateStateVar(stmt);
          break;
        case "ConstDeclaration":
          this.generateStateConst(stmt);
          break;
        case "FunctionDeclaration":
          this.generateFunction(stmt);
          break;
        default:
          // Top-level expressions → constructor
          this.generateStatementInto(stmt, this.constructorLines, 2);
          break;
      }
    }

    // Assemble contract
    const lines: string[] = [];
    lines.push("// SPDX-License-Identifier: MIT");
    lines.push("pragma solidity ^0.8.20;");
    lines.push("");
    lines.push("/**");
    lines.push(" * Generated by LUXBIN-to-EVM Compiler v1.0");
    lines.push(" * Source language: LUXBIN Light Language");
    lines.push(" * https://luxbin.eth — Photonic Smart Contract Development");
    lines.push(" */");
    lines.push(`contract ${this.contractName} {`);

    // Events
    if (this.usesLog) lines.push("    event Log(string message);");
    if (this.usesLogInt) lines.push("    event LogInt(int256 value);");
    if (this.usesLogBool) lines.push("    event LogBool(bool value);");
    if (this.usesLog || this.usesLogInt || this.usesLogBool) lines.push("");

    // State variables
    for (const v of this.stateVars) {
      lines.push("    " + v);
    }
    if (this.stateVars.length > 0) lines.push("");

    // Constructor
    if (this.constructorLines.length > 0 || this.stateArrayInits.length > 0) {
      lines.push("    constructor() {");
      for (const l of this.stateArrayInits) lines.push("        " + l);
      for (const l of this.constructorLines) lines.push("        " + l);
      lines.push("    }");
      lines.push("");
    }

    // Functions
    for (const f of this.functions) {
      lines.push(f);
    }

    lines.push("}");

    return { solidity: lines.join("\n"), warnings: this.warnings };
  }

  // ── State Variables ────────────────────────────────────

  private generateStateVar(decl: LetDeclaration) {
    const sType = solType(decl.typeAnnotation);
    const isArray = decl.value?.type === "ArrayLiteral";

    if (decl.typeAnnotation === "photon_float") {
      this.warnings.push(`Line: Variable "${decl.name}" uses photon_float. Solidity has no native float; using int256 (consider fixed-point scaling).`);
    }

    if (isArray && decl.value?.type === "ArrayLiteral") {
      // Arrays need constructor initialization
      this.stateVars.push(`int256[] public ${decl.name};`);
      for (const el of decl.value.elements) {
        this.stateArrayInits.push(`${decl.name}.push(${this.generateExpr(el)});`);
      }
    } else if (decl.value) {
      const val = this.generateExpr(decl.value);
      if (sType === "string") {
        this.stateVars.push(`string public ${decl.name} = ${val};`);
      } else {
        this.stateVars.push(`${sType} public ${decl.name} = ${val};`);
      }
    } else {
      this.stateVars.push(`${sType} public ${decl.name};`);
    }
  }

  private generateStateConst(decl: ConstDeclaration) {
    const sType = solType(decl.typeAnnotation);
    const val = this.generateExpr(decl.value);
    // Solidity constant must be a compile-time value
    if (sType === "string") {
      this.stateVars.push(`string public constant ${decl.name} = ${val};`);
    } else {
      this.stateVars.push(`${sType} public constant ${decl.name} = ${val};`);
    }
  }

  // ── Functions ──────────────────────────────────────────

  private generateFunction(func: FunctionDeclaration) {
    const params = func.params
      .map((p) => `${solType(p.typeAnnotation, true)} ${p.name}`)
      .join(", ");

    // Determine if function has return statements
    const hasReturn = this.functionHasReturn(func.body);
    const returnType = func.returnType
      ? solType(func.returnType, true)
      : hasReturn
        ? this.inferReturnType(func.body)
        : null;

    let sig = `    function ${func.name}(${params}) public`;
    if (returnType) {
      sig += ` returns (${returnType})`;
    }
    sig += " {";

    const bodyLines: string[] = [];
    bodyLines.push(sig);
    for (const stmt of func.body) {
      this.generateStatementInto(stmt, bodyLines, 2);
    }
    bodyLines.push("    }");
    bodyLines.push("");

    this.functions.push(bodyLines.join("\n"));
  }

  private functionHasReturn(body: Statement[]): boolean {
    for (const stmt of body) {
      if (stmt.type === "ReturnStatement" && stmt.value) return true;
      if (stmt.type === "IfStatement") {
        if (this.functionHasReturn(stmt.consequent)) return true;
        if (stmt.alternate && this.functionHasReturn(stmt.alternate)) return true;
        for (const ac of stmt.alternateConditions) {
          if (this.functionHasReturn(ac.body)) return true;
        }
      }
      if (stmt.type === "WhileStatement" && this.functionHasReturn(stmt.body)) return true;
    }
    return false;
  }

  private inferReturnType(body: Statement[]): string {
    for (const stmt of body) {
      if (stmt.type === "ReturnStatement" && stmt.value) {
        return this.inferExprType(stmt.value);
      }
    }
    return "int256";
  }

  private inferExprType(expr: Expression): string {
    switch (expr.type) {
      case "StringLiteral":
        return "string memory";
      case "BooleanLiteral":
        return "bool";
      case "ArrayLiteral":
        return "int256[] memory";
      case "NumberLiteral":
        return "int256";
      default:
        return "int256";
    }
  }

  // ── Statements ─────────────────────────────────────────

  private generateStatementInto(stmt: Statement, lines: string[], indentLevel: number) {
    const pad = "    ".repeat(indentLevel);

    switch (stmt.type) {
      case "LetDeclaration": {
        const sType = solType(stmt.typeAnnotation, true);
        if (stmt.value?.type === "ArrayLiteral") {
          const elements = stmt.value.elements;
          lines.push(`${pad}int256[] memory ${stmt.name} = new int256[](${elements.length});`);
          elements.forEach((el, i) => {
            lines.push(`${pad}${stmt.name}[${i}] = ${this.generateExpr(el)};`);
          });
        } else if (stmt.value) {
          lines.push(`${pad}${sType} ${stmt.name} = ${this.generateExpr(stmt.value)};`);
        } else {
          lines.push(`${pad}${sType} ${stmt.name};`);
        }
        break;
      }
      case "ConstDeclaration": {
        const sType = solType(stmt.typeAnnotation, true);
        lines.push(`${pad}${sType} ${stmt.name} = ${this.generateExpr(stmt.value)};`);
        break;
      }
      case "Assignment":
        lines.push(`${pad}${stmt.name} = ${this.generateExpr(stmt.value)};`);
        break;
      case "IndexAssignment":
        lines.push(`${pad}${stmt.name}[${this.generateExpr(stmt.index)}] = ${this.generateExpr(stmt.value)};`);
        break;
      case "IfStatement": {
        lines.push(`${pad}if (${this.generateExpr(stmt.condition)}) {`);
        for (const s of stmt.consequent) {
          this.generateStatementInto(s, lines, indentLevel + 1);
        }
        for (const ac of stmt.alternateConditions) {
          lines.push(`${pad}} else if (${this.generateExpr(ac.condition)}) {`);
          for (const s of ac.body) {
            this.generateStatementInto(s, lines, indentLevel + 1);
          }
        }
        if (stmt.alternate) {
          lines.push(`${pad}} else {`);
          for (const s of stmt.alternate) {
            this.generateStatementInto(s, lines, indentLevel + 1);
          }
        }
        lines.push(`${pad}}`);
        break;
      }
      case "WhileStatement":
        lines.push(`${pad}while (${this.generateExpr(stmt.condition)}) {`);
        for (const s of stmt.body) {
          this.generateStatementInto(s, lines, indentLevel + 1);
        }
        lines.push(`${pad}}`);
        break;
      case "ForStatement": {
        // for variable in iterable do ... end
        // If iterable is a number/identifier, use it as a range: for (uint i = 0; i < N; i++)
        const iter = this.generateExpr(stmt.iterable);
        lines.push(`${pad}for (int256 ${stmt.variable} = 0; ${stmt.variable} < ${iter}; ${stmt.variable}++) {`);
        for (const s of stmt.body) {
          this.generateStatementInto(s, lines, indentLevel + 1);
        }
        lines.push(`${pad}}`);
        break;
      }
      case "ReturnStatement":
        if (stmt.value) {
          lines.push(`${pad}return ${this.generateExpr(stmt.value)};`);
        } else {
          lines.push(`${pad}return;`);
        }
        break;
      case "BreakStatement":
        lines.push(`${pad}break;`);
        break;
      case "ContinueStatement":
        lines.push(`${pad}continue;`);
        break;
      case "ExpressionStatement":
        lines.push(`${pad}${this.generateExprStatement(stmt.expression)};`);
        break;
    }
  }

  // ── Expressions ────────────────────────────────────────

  private generateExprStatement(expr: Expression): string {
    // Special handling for function calls that become emit statements
    if (expr.type === "CallExpression") {
      return this.generateFunctionCall(expr.callee, expr.arguments);
    }
    return this.generateExpr(expr);
  }

  private generateExpr(expr: Expression): string {
    switch (expr.type) {
      case "NumberLiteral":
        if (expr.isFloat) {
          this.warnings.push(`Float literal ${expr.value} converted to integer. Solidity has no native floats.`);
          return String(Math.floor(expr.value));
        }
        return String(expr.value);

      case "StringLiteral":
        return `"${expr.value}"`;

      case "BooleanLiteral":
        return expr.value ? "true" : "false";

      case "NilLiteral":
        return "0"; // nil → 0 in Solidity

      case "Identifier":
        return expr.name;

      case "ArrayLiteral":
        // In expression context, arrays are complex. Use inline comment.
        this.warnings.push("Array literal in expression context — Solidity requires explicit array construction.");
        return `/* [${expr.elements.map((e) => this.generateExpr(e)).join(", ")}] */`;

      case "BinaryExpression":
        return this.generateBinary(expr.operator, expr.left, expr.right);

      case "UnaryExpression":
        if (expr.operator === "not") return `!(${this.generateExpr(expr.operand)})`;
        if (expr.operator === "-") return `-(${this.generateExpr(expr.operand)})`;
        return this.generateExpr(expr.operand);

      case "CallExpression":
        return this.generateFunctionCall(expr.callee, expr.arguments);

      case "IndexExpression":
        return `${this.generateExpr(expr.object)}[${this.generateExpr(expr.index)}]`;

      default:
        return "/* unknown expression */";
    }
  }

  private generateBinary(op: string, left: Expression, right: Expression): string {
    const l = this.generateExpr(left);
    const r = this.generateExpr(right);

    switch (op) {
      case "+":
        // If either side is a string, use string.concat
        if (left.type === "StringLiteral" || right.type === "StringLiteral") {
          return `string.concat(${l}, ${r})`;
        }
        return `(${l} + ${r})`;
      case "-": return `(${l} - ${r})`;
      case "*": return `(${l} * ${r})`;
      case "/": return `(${l} / ${r})`;
      case "%": return `(${l} % ${r})`;
      case "^": return `(${l} ** ${r})`; // LUXBIN ^ = Solidity **
      case "==": return `(${l} == ${r})`;
      case "!=": return `(${l} != ${r})`;
      case "<": return `(${l} < ${r})`;
      case ">": return `(${l} > ${r})`;
      case "<=": return `(${l} <= ${r})`;
      case ">=": return `(${l} >= ${r})`;
      case "and": return `(${l} && ${r})`;
      case "or": return `(${l} || ${r})`;
      default: return `(${l} ${op} ${r})`;
    }
  }

  private generateFunctionCall(name: string, args: Expression[]): string {
    const argStrs = args.map((a) => this.generateExpr(a));

    // Map LUXBIN standard library functions to Solidity equivalents
    switch (name) {
      case "photon_print": {
        // Determine argument type and emit appropriate event
        const arg = args[0];
        if (!arg) return 'emit Log("")';
        if (arg.type === "StringLiteral") {
          this.usesLog = true;
          return `emit Log(${argStrs[0]})`;
        }
        if (arg.type === "BooleanLiteral") {
          this.usesLogBool = true;
          return `emit LogBool(${argStrs[0]})`;
        }
        // Default to int
        this.usesLogInt = true;
        return `emit LogInt(${argStrs[0]})`;
      }

      case "photon_input":
        this.warnings.push("photon_input() has no EVM equivalent — smart contracts cannot read user input at runtime.");
        return `/* photon_input not available on EVM */ revert("No runtime input")`;

      case "photon_read":
      case "photon_write":
        this.warnings.push(`${name}() has no EVM equivalent — smart contracts cannot access the filesystem.`);
        return `/* ${name} not available on EVM */`;

      // Math functions
      case "abs":
        return `(${argStrs[0]} >= 0 ? ${argStrs[0]} : -${argStrs[0]})`;
      case "sqrt":
        this.warnings.push("sqrt() requires a library like OpenZeppelin Math or PRBMath for production use.");
        return `_sqrt(${argStrs[0]})`;
      case "pow":
        return `(${argStrs[0]} ** ${argStrs[1]})`;
      case "min":
        return `(${argStrs[0]} < ${argStrs[1]} ? ${argStrs[0]} : ${argStrs[1]})`;
      case "max":
        return `(${argStrs[0]} > ${argStrs[1]} ? ${argStrs[0]} : ${argStrs[1]})`;
      case "floor":
      case "ceil":
      case "round":
        this.warnings.push(`${name}() is a no-op for integers in Solidity.`);
        return argStrs[0] || "0";

      // Trig functions — not native in Solidity
      case "sin":
      case "cos":
      case "tan":
        this.warnings.push(`${name}() requires an external math library on EVM (e.g., Trigonometry.sol).`);
        return `/* ${name}(${argStrs.join(", ")}) — needs trig library */`;

      // String functions
      case "len":
        return `${argStrs[0]}.length`;
      case "concat":
        return `string.concat(${argStrs[0]}, ${argStrs[1]})`;
      case "slice":
        this.warnings.push("slice() requires a custom bytes slicing helper in Solidity.");
        return `/* slice(${argStrs.join(", ")}) */`;
      case "upper":
      case "lower":
        this.warnings.push(`${name}() requires a custom string library in Solidity.`);
        return `/* ${name}(${argStrs[0]}) */`;

      // Wavelength / photonic functions — unique to LUXBIN
      case "wavelength":
      case "char":
        this.warnings.push(`${name}() is a LUXBIN photonic function with no EVM equivalent.`);
        return `/* ${name}(${argStrs.join(", ")}) — photonic encoding */`;

      // Quantum functions
      case "superpose":
      case "measure":
      case "entangle":
      case "hadamard":
      case "cnot":
      case "phase":
      case "teleport":
        this.warnings.push(
          `Quantum function ${name}() has no EVM equivalent. On-chain, consider using Chainlink VRF for randomness.`
        );
        if (name === "measure") {
          return `/* quantum measure — use Chainlink VRF */ uint256(keccak256(abi.encodePacked(block.timestamp, block.prevrandao))) % 2`;
        }
        if (name === "superpose") {
          return `/* quantum superpose */ ${argStrs[0] || "0"}`;
        }
        return `/* quantum ${name}(${argStrs.join(", ")}) */`;

      // Default: pass through as a regular function call
      default:
        return `${name}(${argStrs.join(", ")})`;
    }
  }
}
